# CompletableFuture: composable asynchronous programming
- 非同期タスクを使用して比較的長時間の操作を実行することで、アプリケーションのパフォーマンスと応答性を向上させることができます。特に、1つ以上のリモートの外部サービスに依存している場合はそうです。
- クライアントに非同期APIを提供することを検討すべきです。CompletableFuturesの機能を使えば簡単に実装できます。
- また、CompletableFutureを使用すると、非同期タスク内で発生したエラーを伝播して管理することができます。
- 同期 API の呼び出しを CompletableFuture でラップするだけで、同期 API から非同期に消費することができます。
- 複数の非同期タスクが独立している場合でも、そのうちの 1 つの結果が別の入力として使用されている場合でも、複数の非同期タスクを合成したり、組み合わせたりすることができます。
- CompletableFuture にコールバックを登録して、Future が完了してその結果が利用可能になったときに、いくつかのコードをリアクティブに実行することができます。
- CompletableFuture のリスト内のすべての値が完了したときに判断することもできますし、最初の値だけが完了するのを待つこともできます。

## まとめ
- 非同期計算を作成し、その結果を取得する
- 非ブロッキング操作を使用したスループットの向上
- 非同期APIの設計と実装
- 同期APIを非同期で使用する
- 2つ以上の非同期操作のパイプライン処理とマージ
- 非同期操作の完了への対応


## ソフトウェアの記述方法を再考
1. 並列処理：アプリケーションを実行するハードウェアに関連(fork / joinフレームワー + 並列ストリーム)
2. 並行処理；アプリケーションの構造、特にアプリケーション間の相互作用に関するもの

### アプリケーションの構造、特にアプリケーション間の相互作用に関するものについて
- パブリックAPIを介してアクセス可能なインターネットサービスのアプリケーションによる可用性と使用の増加を反映しています。
- 実行したくないのは、計算をブロックし、これらのサービスからの応答を待機するCPUの数十億の貴重なクロックサイクルを無駄にすることです。

### 同期APIと非同期API
- 同期API
>メソッドへの従来の呼び出しについて話すもう1つの方法です。
それを呼び出すと、呼び出し元はメソッドが計算している間待機し、メソッドは戻り、呼び出し元は戻り値を続行します。
呼び出し元と呼び出し先が異なるスレッドで実行された場合でも、呼び出し元は呼び出し先が完了するのを待ちます。
これにより、呼び出しをブロックするフレーズが発生します。

- 非同期API
>メソッドはすぐに、または少なくともその計算が完了する前に戻り、
残りの計算を呼び出し元に非同期で実行されるスレッドに委任します。
つまり、ノンブロッキング コールというフレーズを使用します。
残りの計算は、コールバックメソッドを呼び出すか、さらに「計算が完了するまで待機する」メソッドを呼び出す呼び出し元のいずれかによって、呼び出し元にその値を提供します。
この計算スタイルは、I / Oシステムプログラミングに共通です。
ディスクアクセスを開始します。
これは、より多くの計算を実行している間、非同期で行われます。
さらに何もする必要がない場合は、ディスクブロックがメモリに読み込まれるまで待つだけです。


## ストリームとCompletableFutureのどちらが並列処理に適しているか？
並列の扱い方は2つ存在します。
1. コレクションを並列ストリームに変換してマップのような操作を使用する方法
2. コレクションを反復処理してCompletableFuture内で操作をスポーンする方法

後者(2)の方が、スレッドプールのサイズ変更を使用してより多くの制御を行うことができ、
固定数のスレッドがすべて I/O を待っているからといって、全体的な計算がブロックされることはありません。

これらのAPIを使用する際のアドバイスは以下の通りです。

- もしあなたがI/Oを使わずに計算量の多い処理を行うのであれば、
Streamインターフェイスが最もシンプルな実装であり、最も効率的である可能性が高いものです。
（もしすべてのスレッドが計算に縛られているのであれば、プロセッサコアよりも多くのスレッドを持つことに意味はありません）

- 作業の並列単位が I/O (ネットワーク接続を含む) の待ち時間を伴う場合、
CompletableFuturesはより柔軟性があり、前に説明したように、待ち時間/コンピュータ、または W/C の比率にスレッドの数を一致させる機能を提供します。
ストリーム処理パイプラインに I/O 待機が含まれている場合に並列ストリームの使用を避けるもう一つの理由は、
ストリームの怠惰性により、実際にいつ待機が発生したかを推論することが難しくなる可能性があるからです。
